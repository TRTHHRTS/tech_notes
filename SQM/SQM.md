# Software quality srash course (SQM)
## Послушал (и посмотрел) курс лекций от Егора Бугаенко по метрикам качества кода и maintainability систем

Ссылка на курс: https://www.youtube.com/watch?v=q9Gr2xguP5I&list=PLaIsQH4uc08xyXRhhYPHh-Yam2kEwNaLl

### Здесь изложу свои мысли по курсу, чтобы не забыть, и для каждой лукции сделаю более подробный анализ и практическое применение

#### SQM_1 - LoC
- чем меньше строчек кода, тем лучше, в общем подходе;
- следует знать сколько строк кода в проектах, с которыми ты работаешь;
- следить за размером проекта, классов, методов, потому что чем меньше - тем понятнее и поддерживаемее;

**Выводы:**
- работал с разными проектами от 1к строк до 100к (монолит), которые распиливал и снижал общий размер кодовой базы монолита на 20%-30% и более;
- средний проект - 5к-15к code size;

#### SQM_2 - CC
- цикломатическая сложность - сложность в понимании метода, класса, модуля;
- для некоторых ЯП есть инструменты, которые ее считают;
- можно использовать как ограничитель, как красную линию для программистов;
- TODO как использовать на практике?!

#### SQM_3 - CoCo
- показывает то, насколько читабельный код
- свежаня метрика, недавно придуманная
- возможная замена CC
- TODO как использовать на практике?!

#### SQM_4 - Halstead Complexity
- метрика про словарный объем в коде;
- то есть чем больше возможностей языка используешь - тем сложнее твой код для понимания;
- а еще, количество багов в программе не зависит ни от чего, кроме объема кода!
- текущее понимание бага отличается от понимания бага в прошлом;
- раньше баг - abnormal termination;
- сейчас баг - несоответствие ожиданиям от работы программы (кода);
- в формуле Холстеда - только баги "прошлого";
- TODO как использовать на практике?!

#### SQM_5 - Maintainability index
- понятие техдолга было придумано в 92 году!
- метрику хорошо использовать как относительную, а не как абсолютную;
- нет четкой формулы, которую приняло бы сообщество;
- можно посчитать sonarqube'ом;
- TODO как использовать на практике?!

#### SQM_6 - Coupling
- про степень связи между модулями (классами);
- чем более слабые связи между модулями - тем лучше для поддерживаемости системы;
- но нельзя всегда выбирать decoupling, потому что это ведет: к усложению взаимодействия, повышенному латенси, увеличению кодой базы -> увеличение сложности;
- есть метрики fan-in и fan-out (про связи класса - кто обращается в класс и к кому обращается данный класс) - fan-out посчитать легко (кроме рефлекшна), fan-in - сложно, ибо нужно учитывать много контекста - ведь много какие библиотеки могут обращаться к этому классу, не только в конкретном модуле;
- fan-out для Java можно контролировать через checkstyle;
- страх декаплинга: когда за интерфейсом мы не знаем реализацию и не знаем, насколько она сложна и длительна или какие ошибки кидает - нужно всегда быть готовым к худшему!!;
почитать про FailFast;
- TODO как использовать на практике?!

#### SQM_7 - Cohesion
- в паре с Coupling;
- про то, как организованы связи внутри класса/модуля;
- чем больше кохизинг - тем лучше;
- есть 6 вариантов кохизинга;
- jPeek для java чтобы посчитать;
- TODO как использовать на практике?!

#### SQM_8 - TCC и LCC
- это про сильный (tight) и слабый (loose) cohesion;
- нужно делать правильные абстракции!
- и больше думать о структуре в начале проектирования метода/класса/модуля/сервиса/системы;
- интерфейсы помогают понять, насколько корректно мы смоделировали реальный мир в системе;
- посчитать так же, через jPeek для Java;
- TODO как использовать на практике?!

#### SQM_9 - CAMC и NHD
- стадия деплоя, тестов и разработки должны стартовать одновременно, чтобы к концу разработки все было уже проверено "на бою";
- классы должны (крайне рекомендуется) реализовывать какие-то интерфейсы!
- decoupling via interfaces
- посчитать можно тем же jpeek
- TODO как использовать на практике?!

#### SQM_10 - Object Dimensions
- статические методы только если вынуждены делать их там, где перформанс важен, иначе - все в объекты загонять лучше (почему? потому что статические методы приводят к coupling - к повышению связанности между классами/модулями, что плохо для дизайна);
- в целом есть много разных метрик, не понятно какие инструменты их считают (можно и самому написать, это кажется не сложно)
- TODO как использовать на практике?!

#### SQM_11 - Clone Coverage
- почитать книгу: The pragmatic programmer: from journeyman to master
- TODO как использовать на практике?!

#### SQM_12 - Dead Code
- речь про неиспользуемый код, которого как бы не должно быть;
- монорепа - дичь (и тут я согласен);
- TODO как использовать на практике?!

#### SQM_13 - Code Churn
- про версионирование;
- code churn - сумма дельт между коммитами, между первым коммитом и последним;
- Егор против squash коммитов, чтобы история полная была в гите, я скорее не согласен с этим;
- TODO как использовать на практике?!

#### SQM_14 - Tech Debt
- 0pdd.com - сайт, который TODO оформляет в issues;
- в приоритете техдолга стоит учитывать, что мотивация закрыть быстро небольшие задачки выше, и иногда стоит так мотивировать?
- TODO как использовать на практике?!

#### SQM_15 - Code Coverage
- покрытие должно мотивировать на написание тестов;
- при этом никакое покрытие не расскажет, что тесты качественные и даже не показывают, на сколько на самом деле покрытие;
- покрытия бывают разные: line, condition, branch и т.д. нужно в комплексе метрики добавлять;
- TODO как использовать на практике?!

#### SQM_16 - Mutation Coverage
- создаем много мутантов кода с незначительными изменениями и проверяем, чтобы тесты упали, а если не упали - значит тесты плохие и неполные;
- PIT для Java;
- TODO как использовать на практике?!

#### SQM_17 - Function Points
- ничего не выписал, не понял как это применить к текущему моменту;
- стоит вернуться к этой лекции попозже;

#### SQM_18 - Defects density
- кол-во ошибок в коде не влияет на mean time to failure (время между падениями системы);
- есть такая мысль: чем больше дефектов найдено в коде - тем лучше этот код (потому что нет кода без ошибок, есть недоисследованный);
- TODO как использовать на практике?!

#### SQM_19 - Comments density
- прочитать книгу Мартина Фаулера: Рефакторинг
- qulice.com
- надо бы подойти к комментариям с другой стороны - посмотреть какие стайлгайды действительно нужно внедрить, а какие - наоборот удалить;
- TODO как использовать на практике?!

#### SQM_20 - Commits Density
- частые коммиты делать более организовано, более грамотно и более профессионально, ибо для этого и нужна система контроля версий;
- как только создали какую-то ценность для проекта - коммитим;
- изменить подход к сквошу мб? Ведь история гита это важно;
- наиболее удачный коммит: 2-4 файла и 6-50 строк;
- в коммит месседжах писать, почему мы сделали этот коммит, а не результат коммита;
- чем меньше коммиты - тем лучше;
- можно коммитить как только скомпилировалось;
- коммиты должны быть по фичам, а не по времени;
- TODO как использовать на практике?!

#### SQM_21 - Builds
- билды должны быть быстрыми, а деплои - частыми;
- это хорошо коррелирует с маленькими коммитами - небольшими изменениями, чтобы постепенно все улучшать и мержить в билды;
- TODO как использовать на практике?!

#### SQM_22 - Code Style
- рассмотреть переход на PMD с checkstyle, потому что он лучше? (лучше ли?)
- qulice (штука Егора);
- markdownlint for markdown;
- xcop for xml!
- TODO как использовать на практике?!

#### SQM_23 Static Analysis
- мы уже используем статический анализ, но надо глянуть на PMD и Qulice;
- TODO как использовать на практике?!

#### SQM_24 Neural Metrics
- по ходу разработки можно находить слабости статического анализа и усиливать правила, а не точечно менять что-то (!);
- шумный статический анализатор (который много false positive генерирует) - это плохо;
- TODO как использовать на практике?!


### Книги, которые собираюсь прочитать по следам лекций:
- Программист-прагматик - Дэмид Томас, Эндрю Хант
- Рефакторинг - Мартин Фаулер
- Совершенный код - С. Макконнелл
